# 10958-checker (Go)

**目的**
「1〜9 を**昇順（1→9）**または**降順（9→1）**に並べたまま、**数字の連結（例：12, 34, 567）**を許可し、**四則演算（+ − × ÷）**と**累乗（^）**、**括弧 ()** だけで**10958 をちょうど表現できるか**（= いわゆる *10958 問題*）を総当たりで検証する」ためのツールです。
計算は有理数（`math/big` の `big.Rat`）で**誤差なく**行います。探索は**区間DP＋ワーカープール**で強めに並列化しつつ、CPU/メモリの使いすぎを避ける設計です。

---

## 特徴

* **順序固定**：1..9 を並べ替えず、そのまま使います（昇順/降順を選択可能）。
* **全桁連結 OK**：任意の連続区間を連結して 1〜9 桁の整数トークンを作れます（例：`[1,2,3,4] → 1, 2, 3, 4 / 12, 3, 4 / 1, 23, 4 / 123, 4 / 1, 234 / 1234 …`）。
* **演算の網羅**：四則演算＋累乗（右辺が**整数**）＋全ての括弧付け（すべての二分木）を総当たり。
* **厳密計算**：`big.Rat` により丸め誤差なし。
* **並列高速化**：ワーカープールで分割区間を並列計算。`-workers` で調整可能。
* **メモリ節約**：同一数値（既約分数として一致）は代表 1 式のみ保持。
* **近似提示**：完全一致が無い場合、目標値に**最も近い式**を上位 N 件表示。

---

## ビルド & 実行

### 前提

* Go 1.18 以上（`math/big` とジェネリクスではなく、通常の構文のみを使用）
* Windows / macOS / Linux 対応

### 実行（ソースのまま）

```bash
# 例: 昇順、目標 10958、ワーカー12、指数上限10、結果3件まで
go run main.go -target 10958 -order asc -workers 12 -maxexp 10 -limit 3
```

### ビルド

```bash
go build -o 10958-checker
./10958-checker -target 10958 -order asc -workers 12 -maxexp 10 -limit 3
```

Windows:

```powershell
go build -o 10958-checker.exe
.\10958-checker.exe -target 10958 -order asc -workers 12 -maxexp 10 -limit 3
```

---

## 使い方（オプション一覧）

| オプション      | 型 / 既定      | 説明                                                            |
| ---------- | ----------- | ------------------------------------------------------------- |
| `-target`  | **必須** / なし | 目標値。`10958` のような整数、`3.5` のような小数、`22/7` のような分数を指定可能。           |
| `-order`   | `asc`       | 数字の順序。`asc`（1→9）または `desc`（9→1）。                              |
| `-limit`   | `10`        | 表示する式の最大件数（完全一致がある場合/無い場合どちらにも適用）。                            |
| `-workers` | CPU 論理コア数   | 並列ワーカー数。CPU に応じて調整。                                           |
| `-maxexp`  | `5`         | 累乗 `^` の**右オペランドが整数**のとき、その**絶対値上限**（例：`a^(±5)` まで）。暴走防止の安全弁。 |

### コマンド例

* 10958 を**昇順**で検証（近傍3件だけ見たい）

  ```bash
  go run main.go -target 10958 -order asc -limit 3 -workers 12 -maxexp 10
  ```
* 10958 を**降順**で検証（指数の探索を広げる）

  ```bash
  go run main.go -target 10958 -order desc -limit 5 -workers 16 -maxexp 15
  ```
* 分数や小数のターゲットも OK

  ```bash
  go run main.go -target 100 -order asc
  go run main.go -target 3.141592 -order asc
  go run main.go -target 22/7 -order asc
  ```

---

## 出力の見方

### 完全一致が見つかった場合

```
目標 10958 に一致した式（最大 3 件）:
[ 1] ((1+234)*(5/(6/(7*8))))-9 = 10958
[ 2] … = 10958
...
```

### 見つからない場合（近似表示）

```
完全一致の式は見つかりませんでした。近い式をいくつか表示します（上位 3 件）：
[ 1] (1+((((2+34)/5)^6)*(7/89))) = 15238866977/1390625  (誤差 0.286365)
[ 2] (((1+234)*(5/(6/(7*8))))-9) = 32873/3  (誤差 0.333333)
[ 3] ((1+((2-((3/4)/56))^7))*89) = 310064408704792084461/28296722014797824  (誤差 0.391251)
```

* `=` の右側は**厳密な有理数表現**（`a/b`）で表示されます。
* `(誤差 …)` は `|式の値 − 目標値|` の実数近似（`float64`）です。

---

## 仕様の詳細

### 探索ルール

* **数字 1〜9 を「順序を崩さずに」すべて 1 回ずつ使用**。
* **数字は連結可能**：任意の連続区間を連結し、1〜9 桁の整数トークンを作る。
  例（昇順）：`1 2 3 4 5 6 7 8 9` → `12 3 4 5 6 7 8 9` / `1 23 4 56 7 89` / `123 45 6 7 8 9` / `123456789` など、**区間DPで全パターン**をカバー。
* **演算**：`+`, `-`, `*`, `/`, `^`（右オペランドは整数のみ、`|exp| ≤ maxexp`）。
* **括弧**：全ての二分木（= すべての括弧付け）を網羅。

### 計算の正確さ

* すべての中間値・最終値を `*big.Rat` で保持し、**丸め誤差ゼロ**。
* 「同一値」は（既約分数文字列キーで）**1 式のみ保持**してメモリを抑制。

### 並列化

* 区間分割（`[i..k]` と `[k+1..j]`）ごとに**ジョブ化**してワーカープールに投入。
* `-workers` で**並列度**を調整（コア数程度が目安）。
  極端に大きくするとコンテキストスイッチ増やし、逆効果になる場合があります。

---

## 典型的なユースケース（10958問題）

* **検証意図**：
  *「昇順 1〜9 をすべて使い、連結・四則・累乗・括弧のみで **10958** を表現できるか？」*

* **結論（現行ルールの実行結果）**：
  少なくとも `-maxexp 10` の探索では**完全一致は見つかりませんでした**。
  必要に応じて `-maxexp` を 15〜20 へ上げて再検証してください（指数が大きいと式が爆発的に増えるため、ワーカー数やメモリと相談）。

> 注：`-maxexp` を上げると探索空間が急増します。適度な値を推奨。

---

## パフォーマンスの目安とコツ

* **workers**：CPU 論理コア数を基準に調整（例：8〜16）。
* **maxexp**：まずは 8〜10 で試し、必要に応じて段階的に引き上げ。
* **limit**：出力量を抑えるため、最初は小さめ（3〜10）。
* **asc/desc**：降順に切り替えると探索の性質が変わるため、両方を試すのも手。

---

## 制限・非対応

* **順序入れ替え（Permutation）**：不可（昇順 or 降順のみ）。
* **数字の再利用/スキップ**：不可（1〜9 の全てを 1 度ずつ使用）。
* **不連続連結**：不可（連結は**連続する**数字に限る）。
* **演算の種類**：`+ - * / ^ ()` のみ。**小数点挿入、階乗、√、n乗根、結合子、文字列の逆順**などはありません。
* **指数の右辺**：**整数のみ**。かつ `|指数| ≤ -maxexp` の制限あり（指定値）。

---

## 典型的なトラブルシューティング

* **`expected type argument list` のようなエラー**
  → コードの古い誤植が原因でした（最新版では解消）。`map[string]Expr{}` になっていることを確認してください。

* **`*big.Rat` に `Reduce()` が無い**
  → `SetFrac` が既約化まで行います。`Reduce()` 呼び出しは不要（最新版では呼んでいません）。

* **CPU/メモリが厳しい**
  → `-workers` を下げる、`-maxexp` を小さくする、`-limit` を小さくする。
  それでも厳しい場合、保持戦略（重複除去の閾値や途中段階のサンプリング）を入れる拡張が必要です。

---

## 実装の概略（アルゴリズム）

1. **初期化（連結の導入）**
   全ての区間 `[i, j]` について、**連結した整数**（例：`[2,3,4] → 234`）を**初期候補**として `cache[i,j]` に入れる。

2. **区間DP**
   区間長を 2→…→9 に伸ばしながら、すべての分割 `k` に対して
   `cache[i,k] (左)` と `cache[k+1,j] (右)` を **全演算**（`+ - * / ^`）で合成。
   得られた数値を `cache[i,j]` に追加（同値は 1 つにまとめる）。

3. **並列化**
   各分割 `(i,k,j)` を**ジョブ**としてワーカープールに投入。
   ジョブ完了結果をメインが受け取り、`cache` にマージ。

4. **判定**
   最終区間 `cache[0,8]`（= 1〜9 全体）に**目標値**があれば式を出力。無ければ**近似上位 N** を表示。

---

## よくある質問（FAQ）

* **Q. 実行したらすぐ終わりますか？**
  A. はい。1 回の実行で「全探索→出力→終了」の**バッチ**動作です。

* **Q. 指数の上限を外せますか？**
  A. 探索空間が爆発するため、既定では上限ありです。どうしても必要なら自己責任で `-maxexp` を大きくしてください。実装の安全弁を外すことも可能ですが推奨しません。

* **Q. 完全一致が無いのに近似が表示されるのはなぜ？**
  A. 検証時の参考のため、目標に一番近い式を提示しています。**存在証明ではありません**が、実務上のヒントになります。

---

## ライセンス

（必要に応じて追記してください。社内利用のみ等）

---

## 謝辞 / 背景

本ツールは「**10958 問題**」の検証用途として設計されています。
**順序固定・全桁使用・連結あり・四則＋累乗＋括弧のみ**という厳格なルールで、**厳密計算**かつ**強力な並列総当たり**により「存在するか否か」を実用時間で確認することを目指しています。

---

## 参考コマンド（再掲）

```bash
# 昇順・ワーカー12・指数上限10・上位3件表示で 10958 を検証
go run main.go -target 10958 -order asc -workers 12 -maxexp 10 -limit 3

# 降順でも検証
go run main.go -target 10958 -order desc -workers 12 -maxexp 10 -limit 3

# 指数探索を少し広げる（計算コスト増に注意）
go run main.go -target 10958 -order asc -workers 12 -maxexp 15 -limit 5
```

---